[1mdiff --git a/src/cpu.rs b/src/cpu.rs[m
[1mindex a95e09b..c234f98 100644[m
[1m--- a/src/cpu.rs[m
[1m+++ b/src/cpu.rs[m
[36m@@ -1,91 +1,177 @@[m
 struct CPU {[m
     clock: Clock,[m
[31m-    registers: Registers[m
[32m+[m[32m    registers: Registers,[m
 }[m
 [m
 impl CPU {[m
     pub fn new() -> Self {[m
         CPU {[m
[31m-            clock: Clock {[m
[31m-                m: 0, t: 0[m
[31m-            },[m
[32m+[m[32m            clock: Clock { m: 0, t: 0 },[m
             registers: Registers {[m
[31m-                a: 0, b: 0, c: 0, d: 0, e: 0,[m
[31m-                h: 0, l: 0, flags: 0,[m
[31m-                pc: 0, sp: 0,[m
[31m-                m: 0, t: 0[m
[31m-            }[m
[32m+[m[32m                a: 0,[m
[32m+[m[32m                b: 0,[m
[32m+[m[32m                c: 0,[m
[32m+[m[32m                d: 0,[m
[32m+[m[32m                e: 0,[m
[32m+[m[32m                h: 0,[m
[32m+[m[32m                l: 0,[m
[32m+[m[32m                flags: 0,[m
[32m+[m[32m                pc: 0,[m
[32m+[m[32m                sp: 0,[m
[32m+[m[32m                m: 0,[m
[32m+[m[32m                t: 0,[m
[32m+[m[32m            },[m
         }[m
     }[m
[31m-    pub fn get_clock(&self) -> &Clock {[m
[31m-        &self.clock[m
[31m-    }[m
     pub fn tick(&mut self) {[m
[31m-        self.clock.m += 1;[m
[31m-        self.clock.t += 4;[m
[32m+[m[32m        self.clock.tick()[m
     }[m
 }[m
 [m
 #[derive(Clone)][m
 struct Clock {[m
     m: u8,[m
[31m-    t: u8[m
[32m+[m[32m    t: u8,[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mimpl Clock {[m
[32m+[m[32m    pub fn tick(&mut self) {[m[41m [m
[32m+[m[32m        self.m += 1;[m
[32m+[m[32m        self.t += 4;[m
[32m+[m[32m    }[m
 }[m
 [m
 struct Registers {[m
[31m-    a: u8, b: u8, c: u8, d: u8, e: u8,[m
[31m-    h: u8, l: u8,[m
[32m+[m[32m    a: u8,[m
[32m+[m[32m    b: u8,[m
[32m+[m[32m    c: u8,[m
[32m+[m[32m    d: u8,[m
[32m+[m[32m    e: u8,[m
[32m+[m[32m    h: u8,[m
[32m+[m[32m    l: u8,[m
     flags: u8,[m
[31m-    pc: u16, sp: u16,[m
[31m-    m: u8, t: u8[m
[32m+[m[32m    pc: u16,[m
[32m+[m[32m    sp: u16,[m
[32m+[m[32m    m: u8,[m
[32m+[m[32m    t: u8,[m
 }[m
 [m
 impl Registers {[m
[31m-    pub fn fetch8(&self, register: Register8) -> u8 {[m
[32m+[m[32m    pub fn fetch8(&self, register: R8) -> u8 {[m
         match register {[m
[31m-            a => self.a, b => self.b, c => self.c,[m
[31m-            d => self.d, e => self.e,[m
[31m-            h => self.h, l => self.l,[m
[31m-            m => self.m, t => self.t[m
[32m+[m[32m            R8::A => self.a,[m
[32m+[m[32m            R8::B => self.b,[m[41m [m
[32m+[m[32m            R8::C => self.c,[m
[32m+[m[32m            R8::D => self.d,[m[41m [m
[32m+[m[32m            R8::E => self.e,[m
[32m+[m[32m            R8::H => self.h,[m
[32m+[m[32m            R8::L => self.l,[m
[32m+[m[32m            R8::M => self.m,[m
[32m+[m[32m            R8::T => self.t,[m
         }[m
     }[m
[31m-    pub fn fetch16(&self, register: Register16) -> u16 {[m
[32m+[m[32m    pub fn fetch16(&self, register: R16) -> u16 {[m
         match register {[m
[31m-            Register16::pc => self.pc, sp => self.sp,[m
[31m-            Register16::bc => u8s_to_u16(self.b, self.c),[m
[31m-            Register16::de => u8s_to_u16(self.d, self.e),[m
[31m-            Register16::hl => u8s_to_u16(self.h, self.l)[m
[32m+[m[32m            R16::PC => self.pc,[m
[32m+[m[32m            R16::SP => self.sp,[m
[32m+[m[32m            R16::BC => u8s_to_u16(self.b, self.c),[m
[32m+[m[32m            R16::DE => u8s_to_u16(self.d, self.e),[m
[32m+[m[32m            R16::HL => u8s_to_u16(self.h, self.l),[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    pub fn set8(&mut self, register: R8, value: u8) {[m
[32m+[m[32m        let reg = match register {[m
[32m+[m[32m            R8::A => &mut self.a,[m
[32m+[m[32m            R8::B => &mut self.b,[m
[32m+[m[32m            R8::C => &mut self.c,[m
[32m+[m[32m            R8::D => &mut self.d,[m
[32m+[m[32m            R8::E => &mut self.e,[m
[32m+[m[32m            R8::H => &mut self.h,[m
[32m+[m[32m            R8::L => &mut self.l,[m
[32m+[m[32m            R8::M => &mut self.m,[m
[32m+[m[32m            R8::T => &mut self.t,[m
[32m+[m[32m        };[m
[32m+[m[32m        *reg = value;[m
[32m+[m[32m    }[m
[32m+[m[32m    pub fn set16(&mut self, register: R16, value: u16) {[m
[32m+[m[32m        match register {[m
[32m+[m[32m            R16::PC => self.pc = value,[m
[32m+[m[32m            R16::SP => self.sp = value,[m
[32m+[m[32m            R16::BC => {[m
[32m+[m[32m                let val = u16_to_u8_tuple(value);[m
[32m+[m[32m                self.b = val.0;[m
[32m+[m[32m                self.c = val.1;[m
[32m+[m[32m            }[m
[32m+[m[32m            R16::DE => {[m
[32m+[m[32m                let val = u16_to_u8_tuple(value);[m
[32m+[m[32m                self.d = val.0;[m
[32m+[m[32m                self.e = val.1;[m
[32m+[m[32m            }[m
[32m+[m[32m            R16::HL => {[m
[32m+[m[32m                let val = u16_to_u8_tuple(value);[m
[32m+[m[32m                self.h = val.0;[m
[32m+[m[32m                self.l = val.1;[m
[32m+[m[32m            }[m
         }[m
     }[m
 }[m
 [m
 pub fn u8s_to_u16(high: u8, low: u8) -> u16 {[m
[31m-    let top = (high as u16) << 8;[m
[31m-    top + (low as u16)[m
[32m+[m[32m    let high = (high as u16) << 8;[m
[32m+[m[32m    high + (low as u16)[m
 }[m
 [m
 pub fn u16_to_u8_tuple(wbyte: u16) -> (u8, u8) {[m
[31m-    ((wbyte << 8) as u8, wbyte as u8)[m
[32m+[m[32m    ((wbyte >> 8) as u8, wbyte as u8)[m
 }[m
 [m
[31m-pub enum Register8 {[m
[31m-    a, b, c, d, e,[m
[31m-    h, l,[m
[32m+[m[32mpub enum R8 {[m
[32m+[m[32m    A,[m
[32m+[m[32m    B,[m
[32m+[m[32m    C,[m
[32m+[m[32m    D,[m
[32m+[m[32m    E,[m
[32m+[m[32m    H,[m
[32m+[m[32m    L,[m
[32m+[m[32m    M,[m
[32m+[m[32m    T,[m
 }[m
 [m
[31m-pub enum Register16 {[m
[31m-    pc, sp, bc, de, hl[m
[32m+[m[32mpub enum R16 {[m
[32m+[m[32m    PC,[m
[32m+[m[32m    SP,[m
[32m+[m[32m    BC,[m
[32m+[m[32m    DE,[m
[32m+[m[32m    HL,[m
 }[m
 [m
 #[cfg(test)][m
 mod test {[m
     use super::*;[m
     #[test][m
[32m+[m[32m    fn u16_splitting_and_combining_rational() {[m
[32m+[m[32m        use std::u16::MAX;[m
[32m+[m[32m        for i in 0..MAX {[m
[32m+[m[32m            let (high, low) = u16_to_u8_tuple(i);[m
[32m+[m[32m            assert_eq!(i, u8s_to_u16(high, low));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn u8_combining_and_splitting_rational() {[m
[32m+[m[32m        use std::u8::MAX;[m
[32m+[m[32m        for i in 0..MAX {[m
[32m+[m[32m            for j in 0..MAX {[m
[32m+[m[32m                let combined = u8s_to_u16(i, j);[m
[32m+[m[32m                assert_eq!((i, j), u16_to_u8_tuple(combined));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    #[test][m
     fn cpu_can_tick() {[m
         let mut cpu = CPU::new();[m
[31m-        let old_clock = cpu.get_clock().clone();[m
[32m+[m[32m        let old_clock = cpu.clock.clone();[m
         cpu.tick();[m
[31m-        let new_clock = cpu.get_clock();[m
[32m+[m[32m        let new_clock = cpu.clock;[m
         let diff_m = new_clock.m - old_clock.m;[m
         let diff_t = new_clock.t - old_clock.t;[m
         assert_eq!(diff_t, 4); // t clock increases 4 per tick[m
[36m@@ -97,9 +183,32 @@[m [mmod test {[m
         cpu.registers.a = 1;[m
         cpu.registers.b = 1;[m
         cpu.registers.c = 1;[m
[31m-        assert_eq!(cpu.registers.a, cpu.registers.fetch8(Register8::a));[m
[31m-        assert_eq!(1, cpu.registers.fetch8(Register8::a));[m
[31m-        assert_eq!(u8s_to_u16(cpu.registers.b, cpu.registers.c), cpu.registers.fetch16(Register16::bc));[m
[31m-        assert_eq!(257, cpu.registers.fetch16(Register16::bc));[m
[32m+[m[32m        assert_eq!(cpu.registers.a, cpu.registers.fetch8(R8::A));[m
[32m+[m[32m        assert_eq!([m
[32m+[m[32m            u8s_to_u16(cpu.registers.b, cpu.registers.c),[m
[32m+[m[32m            cpu.registers.fetch16(R16::BC)[m
[32m+[m[32m        );[m
[32m+[m[32m        assert_eq!(0b100000001, cpu.registers.fetch16(R16::BC));[m
[32m+[m[32m    }[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn cpu_can_set_8bit_registers() {[m
[32m+[m[32m        let mut cpu1 = CPU::new();[m
[32m+[m[32m        cpu1.registers.a = 1;[m
[32m+[m[32m        let mut cpu2 = CPU::new();[m
[32m+[m[32m        cpu2.registers.set8(R8::A, 1);[m
[32m+[m[32m        assert_eq!(cpu1.registers.a, cpu2.registers.a);[m
     }[m
[31m-}[m
\ No newline at end of file[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn cpu_can_set_16bit_registers() {[m
[32m+[m[32m        let mut cpu1 = CPU::new();[m
[32m+[m[32m        cpu1.registers.b = 1;[m
[32m+[m[32m        cpu1.registers.c = 1;[m
[32m+[m[32m        let mut cpu2 = CPU::new();[m
[32m+[m[32m        cpu2.registers.set16(R16::BC, u8s_to_u16(1, 1));[m
[32m+[m[32m        assert_eq!([m
[32m+[m[32m            cpu1.registers.fetch16(R16::BC),[m
[32m+[m[32m            cpu2.registers.fetch16(R16::BC)[m
[32m+[m[32m        );[m
[32m+[m[32m        assert_eq!(0b100000001, cpu2.registers.fetch16(R16::BC));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
